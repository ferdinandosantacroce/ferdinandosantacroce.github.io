[{"content":"Some time ago I spent a wonderful evening with Adrian BolboacÄƒ, trying for the first time in public a pair programming technique I had observed and experimented in companies where I worked.\nIn this post, I\u0026rsquo;ll tell you about the characteristics of this approach.\nTraditional pair programming Pair programming is a cornerstone practice of eXtreme Programming (XP), and I won\u0026rsquo;t go into detail explaining it. You can find a comprehensive description on the good old C2 Wiki.\nThere are various ways to do pair programming; in his latest book, \u0026ldquo;Practical Remote Pair Programming,\u0026rdquo; Adrian illustrates very well some of the most commonly used approaches.\nNormally, pair programming practice is quite disciplined; roles are well-defined, and there are rules and timings to respect.\nDiscipline is one of the strengths of the technique, especially at the beginning of the journey toward XP.\nThrough this practice, continuous collaboration with colleagues is triggered, strengthening the individual\u0026rsquo;s ability to understand and elaborate domain concepts.\nAfter years of practice, a stable team reaches a high mastery of their application domain, technologies, and techniques adopted by the team.\nAt that point, \u0026ldquo;classic\u0026rdquo; pair programming often ends up feeling restrictive, and it\u0026rsquo;s in these occasions that it\u0026rsquo;s possible to loosen the rules a bit and move to a more elastic working mode.\nElastic pair programming The name \u0026ldquo;elastic pair programming\u0026rdquo; came as a bit of a surprise; before discussing with Adi, I had never thought of this approach as something defined, to which I could give a name.\nDespite this, I\u0026rsquo;d say the definition well represents the main characteristic of the approach, namely the elasticity of rules and roles.\nTo tell the truth, there\u0026rsquo;s only one rule: ideas (and keyboard) are exchanged continuously.\nI found this way of working very effective in different situations.\nThe most classic is when there are two people at the keyboard who have known each other for a long time, both experienced professionals.\nThey don\u0026rsquo;t necessarily have to be experts in the same domain or the same techniques; in fact, I\u0026rsquo;ve often found it interesting to encourage confrontation between different points of view.\nThe idea is that, faced with a thorny or peculiar problem, an expert developer calls upon a peer to share and possibly refute the solution hypothesis, and perhaps arrive at a better or unexpected solution for both.\nI\u0026rsquo;ve often used this technique in \u0026ldquo;on-demand\u0026rdquo; mode, involving colleagues who don\u0026rsquo;t normally pair program with me or in teams where the practice wasn\u0026rsquo;t customary.\nThe practice is also interesting for \u0026ldquo;unblocking\u0026rdquo; colleagues who are skeptical about pair programming.\nIt happened to me to be welcomed into a team of only seniors, all very skilled in the application domain, where everyone developed quite independently from others.\nI needed to learn quickly, so I tried to introduce pair programming practice in the team to encourage sharing opportunities; although colleagues were available, their impatience with the rules imposed by the practice was quite evident to me.\nAt that point, when I understood that the pair programming experiment would inevitably fail, I looked for approaches and solutions to not lose the opportunities for confrontation, so useful for me (but ultimately for the entire team).\nIn this situation, we therefore relaxed the rules, allowing ourselves to take the keyboard at any moment to intervene.\nTests, implementations, and solutions then began to emerge more easily, and so did discussions about language details, patterns, or different approaches that each of us, through experience, had accumulated over the years.\nIn this situation, I still managed to obtain the benefits of knowledge sharing, very important for me, giving up the \u0026ldquo;side-effect\u0026rdquo; (which I still appreciate) of discipline and cadence that traditional pair programming provides.\nAnother situation I remember well was what happened when I worked with my colleagues in guilds.\nGuilds are a very powerful tool that the company made available to us for learning, growing, and improving our capabilities.\nIn guilds, ad-hoc teams work on a project proposed and chosen by them, with the aim of exploring new technologies or approaches.\nIn situations like these, very relaxed and open to confrontation, we found benefit in working using this elastic style of pair programming, and it was then quite natural for us to evolve to what is now commonly referred to as ensemble (Mob) programming.\nPitfalls This technique has only one rule, but you need to be careful: it\u0026rsquo;s precisely when there are few rules that it\u0026rsquo;s easier to make mistakes.\nThis approach can easily become a system for not doing pair programming; having no \u0026ldquo;obligations,\u0026rdquo; it\u0026rsquo;s easy to fall into the anti-pattern where the driver writes code and works alone, while the navigator thinks about something else\u0026hellip;\nIn this situation, it\u0026rsquo;s better to go back to working individually and perhaps reflect at the team level on what prevents this kind of collaboration and what alternatives we have to continue maintaining a high flow of information between people.\nEven in elastic pair programming mode, working agreements are established, including for example keeping smartphones and distractions away.\nOn some occasions, I\u0026rsquo;ve worked in pairs with a second computer in addition to the main one, a bit like what\u0026rsquo;s also allowed in ensemble programming. The secondary computer is for support: the navigator can use it, for example, to search for something online while the driver remains focused on the code, certainly not to mind their own business. The goal always remains to write code and solve problems together.\nAnother recommendation is not to use this technique without experience in traditional pair programming, or between two people who are both not well-versed in technique and/or domain. In this case, you easily risk losing your bearings and foundering.\nAs a famous Italian commercial said a few years ago, elastic pair programming is for many, but not for everyone ðŸ™‚\nThe trick I use to decide whether it\u0026rsquo;s appropriate to use this approach is to ask myself a simple question: \u0026ldquo;Could you solve this problem alone?\u0026rdquo; If the answer is something like \u0026ldquo;Yes, but I\u0026rsquo;m curious to know how -insert name here- would solve it\u0026rdquo;, there are the premises for a good elastic pair programming session.\nRemote elastic pair programming The experience with Adi made me understand that this style can also work remotely.\nIn fact, the continuous search for consensus and role exchange keeps people\u0026rsquo;s attention high, preventing physical distance from lowering confrontation and exchange of ideas.\nFor a few years now, I\u0026rsquo;ve stopped being a full-time programmer, although I often do my work as a coach and trainer in software development teams.\nIn the experiences I\u0026rsquo;ve gained in the last year and a half of forced remote work, I\u0026rsquo;ve been able to observe the effectiveness of this style, even though people were often unaware of doing this kind of pair programming ðŸ™‚\nConclusions I don\u0026rsquo;t think I invented anything new with this technique, perhaps just gave a name to a practice that many programmers already adopt.\nI hope this awareness adds one more option to your toolbox ðŸ˜‰\n","date":"2021-04-12T00:00:00Z","image":"https://ferdinandosantacroce.it/p/elastic-pair-programming/cover_hu_86f729787586e9bb.jpg","permalink":"https://ferdinandosantacroce.it/p/elastic-pair-programming/","title":"Elastic Pair Programming"}]